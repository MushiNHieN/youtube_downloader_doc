{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Youtube Downloader","text":"<p>En este tutorial aprender\u00e1s a c\u00f3mo crear tu propio programa en Python para descargar m\u00fasica y v\u00eddeos.</p> <p></p> <p>Podr\u00e1s seguir este tutorial sin tener conocimientos sobre programaci\u00f3n, pero ser\u00e1 mucho m\u00e1s sencillo si conoces  los fundamentos o si ya has programado en Python.</p> <p>En este tutorial se sobreentiende que ya tienes instalado Python, si todav\u00eda no lo tienes puedes ver una gu\u00eda aqu\u00ed.</p> <p>Puedes empezar el tutorial aqu\u00ed.</p>"},{"location":"codigo/interfaz/componentes/","title":"Componentes de la interfaz","text":"<p>Ahora que tenemos nuestro <code>root</code> configurado, empezaremos a crear los componentes que formar\u00e1n nuestra interfaz.</p> <p>Pondremos todos estos componentes debajo de la configuraci\u00f3n de <code>root</code>.</p>"},{"location":"codigo/interfaz/componentes/#entrada-de-los-links","title":"Entrada de los links","text":"<p>Para crear la entrada donde introduciremos los links para descargar, crearemos una instancia de <code>ctk.CTkEntry</code> y renderizaremos con <code>.pack()</code>:</p> <pre><code>link_entry = ctk.CTkEntry(root,\n                           placeholder_text='Introduce un link o una lista de reproducci\u00f3n de YouTube',\n                           width=600)\nlink_entry.pack(pady=30)\n</code></pre> <p>Los componentes necesitan una instancia en la que ser colocados. Eso ser\u00e1 el primer par\u00e1metro: <code>root</code>.</p> <p>En el caso de <code>link_entry</code>, adem\u00e1s colocaremos un <code>placeholder_text</code>, que no es m\u00e1s que el texto predefinido que tendr\u00e1 dentro.</p> <p>Tambi\u00e9n le daremos un ancho (<code>width</code>) de 600px, para que ocupe casi todo el espacio.</p> <p>Por \u00faltimo, en el m\u00e9todo pack le diremos que tenga un padding vertical (<code>pady</code>) de 30px para que no est\u00e9 pegado a la parte superior de la ventana.</p> <p>Puedes ver c\u00f3mo va quedando ejecutando el archivo del programa.</p> <p>Hasta ahora deber\u00eda verse as\u00ed:</p> <p></p>"},{"location":"codigo/interfaz/componentes/#etiqueta-para-los-links","title":"Etiqueta para los links","text":"<p>Crearemos una etiqueta para avisar de si hay alg\u00fan error con los links:</p> <pre><code>link_label = ctk.CTkLabel(root, text='', text_color='red')\nlink_label.pack()\n</code></pre> <p>Le pondremos un <code>text_color</code> red.</p>"},{"location":"codigo/interfaz/componentes/#boton-de-seleccion-de-directorio","title":"Bot\u00f3n de selecci\u00f3n de directorio","text":"<p>Ahora crearemos un bot\u00f3n para seleccionar d\u00f3nde queremos que se descarguen nuestros links.</p> <p>Para ello, crearemos una instancia de <code>ctk.CTkButton</code>:</p> <pre><code>output_button = ctk.CTkButton(root, text='Seleccionar directorio')\noutput_button.pack()\n</code></pre> <p><code>text</code> es el texto que tendr\u00e1 el bot\u00f3n.</p>"},{"location":"codigo/interfaz/componentes/#etiqueta-para-directorio","title":"Etiqueta para directorio","text":"<p>Tambi\u00e9n crearemos una etiqueta o label con una instancia de <code>ctk.CTkLabel</code>:</p> <pre><code>output_label = ctk.CTkLabel(root, text='', text_color='cyan')\noutput_label.pack()\n</code></pre> <p>La dejaremos vac\u00eda, puesto que servir\u00e1 para mostrar la ruta que hemos seleccionado para las descargas. Le pondremos un <code>text_color</code> cyan.</p>"},{"location":"codigo/interfaz/componentes/#checkbox-para-mp3-y-mp4","title":"Checkbox para .mp3 y .mp4","text":"<p>A continuaci\u00f3n crearemos los checkbox para los formatos de salida del link con instancias de <code>ctk.CTkCheckBox</code>:</p> <pre><code>mp3_checked = ctk.StringVar(value=\"off\")\nmp4_checked = ctk.StringVar(value=\"off\")\n\nmp3_checkbox = ctk.CTkCheckBox(\n    master=root, text='.mp3', variable=mp3_checked,  onvalue='on', offvalue='off')\nmp3_checkbox.pack(pady=10)\n\nmp4_checkbox = ctk.CTkCheckBox(\n    master=root, text='.mp4', variable=mp4_checked,  onvalue='on', offvalue='off')\nmp4_checkbox.pack(pady=10)\n</code></pre> <p><code>mp3_checked</code> y <code>mp4_checked</code> son variables que servir\u00e1n para guardar el estado de los checkbox.</p> <p>Los par\u00e1metros <code>onvalue</code> y <code>offvalue</code> son los valores que tendr\u00e1 la variable que hayamos puesto en <code>variable</code>, en este caso <code>mp3_checked</code> y <code>mp4_checked</code>. El valor de las mismas cambiar\u00e1 en funci\u00f3n de si el checkbox est\u00e1 chequeado o no.</p>"},{"location":"codigo/interfaz/componentes/#boton-de-descarga","title":"Bot\u00f3n de descarga","text":"<p>Despu\u00e9s crearemos el bot\u00f3n de descarga:</p> <pre><code>download_button = ctk.CTkButton(root, text='Descargar')\ndownload_button.pack(pady=10)\n</code></pre>"},{"location":"codigo/interfaz/componentes/#etiqueta-para-la-lista-de-reproduccion","title":"Etiqueta para la lista de reproducci\u00f3n","text":"<p>Crearemos una etiqueta para mostrar el t\u00edtulo de la lista de reproducci\u00f3n que estamos descargando:</p> <pre><code>playlist_label = ctk.CTkLabel(root, text='', wraplength=400, text_color='cyan')\nplaylist_label.pack()\n</code></pre> <p>El atributo <code>wraplength</code> sirve para indicar en qu\u00e9 punto queremos que el texto de la etiqueta salte a la siguiente l\u00ednea, ocupando as\u00ed menos espacio.</p> <p>El atributo <code>text_color</code> es para cambiar el color del texto de la etiqueta. Nosotros lo pondremos color <code>cyan</code>, aunque puedes ponerlo del color que quieras. Es recomendable que sea de un color que facilite la legibilidad.</p> <p>Puedes usar el nombre de un color o valores <code>hex</code> (#ff4335).</p>"},{"location":"codigo/interfaz/componentes/#etiqueta-para-la-descarga-actual","title":"Etiqueta para la descarga actual","text":"<p>Tambi\u00e9n crearemos una etiqueta para mostrar el t\u00edtulo del v\u00eddeo que estamos descargando, as\u00ed como para indicar que la descarga ha terminado.</p> <pre><code>complete_label = ctk.CTkLabel(root, text='', wraplength=400)\ncomplete_label.pack()\n</code></pre>"},{"location":"codigo/interfaz/componentes/#etiqueta-con-el-contador-para-la-lista-de-reproduccion","title":"Etiqueta con el contador para la lista de reproducci\u00f3n","text":"<p>Crearemos una etiqueta para mostrar por qu\u00e9 video va la descarga y el total de v\u00eddeos de la lista de reproducci\u00f3n:</p> <pre><code>count_label = ctk.CTkLabel(root, text='', text_color='cyan')\ncount_label.pack()\n</code></pre>"},{"location":"codigo/interfaz/componentes/#boton-para-mostrar-las-descargas","title":"Bot\u00f3n para mostrar las descargas","text":"<p>Por \u00faltimo crearemos un bot\u00f3n para abrir el directorio de descargas una vez hayan terminado:</p> <pre><code>open_folder_button = ctk.CTkButton(root, text='Abrir descargas')\n</code></pre> <p>No haremos <code>.pack()</code> porque queremos mostrar el bot\u00f3n cuando hayan terminado las descargas.</p> <p>Con esto ya hemos terminado de crear nuestra interfaz. Deber\u00eda verse as\u00ed:</p> <p></p> <p>Y nuestro c\u00f3digo as\u00ed:</p> <pre><code>from pytube import YouTube, Playlist\nimport customtkinter as ctk\nimport re\nimport threading\nimport os\n\n\nroot = ctk.CTk()\nroot.title('Youtube Downloader')\nroot.geometry('700x450')\nroot.iconbitmap('youtube.ico')\n\n\nlink_entry = ctk.CTkEntry(root,\n                          placeholder_text='Introduce un link o una lista de reproducci\u00f3n de YouTube',\n                          width=600)\nlink_entry.pack(pady=30)\n\noutput_button = ctk.CTkButton(root, text='Seleccionar directorio')\noutput_button.pack()\n\noutput_label = ctk.CTkLabel(root, text='', text_color='cyan')\noutput_label.pack()\n\nmp3_checked = ctk.StringVar(value=\"off\")\nmp4_checked = ctk.StringVar(value=\"off\")\n\nmp3_checkbox = ctk.CTkCheckBox(\n    master=root, text='.mp3', variable=mp3_checked,  onvalue='on', offvalue='off')\nmp3_checkbox.pack(pady=10)\n\nmp4_checkbox = ctk.CTkCheckBox(\n    master=root, text='.mp4', variable=mp4_checked,  onvalue='on', offvalue='off')\nmp4_checkbox.pack(pady=10)\n\ndownload_button = ctk.CTkButton(root, text='Descargar')\ndownload_button.pack(pady=10)\n\nplaylist_label = ctk.CTkLabel(root, text='', wraplength=400, text_color='cyan')\nplaylist_label.pack()\n\ncomplete_label = ctk.CTkLabel(root, text='', wraplength=400)\ncomplete_label.pack()\n\ncount_label = ctk.CTkLabel(root, text='', text_color='cyan')\ncount_label.pack()\n\nopen_folder_button = ctk.CTkButton(root, text='Abrir descargas')\n\nroot.mainloop()\n\n</code></pre> <p>Ahora que ya tenemos nuestra interfaz terminada, vayamos con la l\u00f3gica de nuestro programa.</p>"},{"location":"codigo/interfaz/root/","title":"Creando root","text":"<p>Una vez tengamos importados los m\u00f3dulos que vamos a utilizar, empezaremos creando la interfaz de nuestro programa.</p>"},{"location":"codigo/interfaz/root/#root","title":"Root","text":"<p>Para ello, crearemos una instancia de <code>customtkinter</code> a la que llamaremos <code>root</code>:</p> <pre><code>root = ctk.CTk()\n</code></pre> <p>Esta ser\u00e1 la base de nuestra interfaz. Ahora llamaremos a la funci\u00f3n <code>mainloop()</code> de nuestro <code>root</code>:</p> <pre><code>root.mainloop()\n</code></pre> <p>Esta l\u00ednea debe de ir siempre abajo de nuestro c\u00f3digo.</p>"},{"location":"codigo/interfaz/root/#comprobando-que-funciona","title":"Comprobando que funciona","text":"<p>Ahora para comprobar que todo funciona correctamente ejecutaremos nuestro archivo <code>youtube_downloader.py</code>. Podemos hacerlo haciendo click en el bot\u00f3n de reproducir de arriba a la derecha en la ventana de VSC o abriendo una terminal y escribiendo:</p> <p><code>python youtube_downloader.py</code></p> <p>Si lo hemos hecho todo bien deber\u00eda aparecer la ventana de nuestro programa.</p> <p></p>"},{"location":"codigo/interfaz/root/#configurando-root","title":"Configurando root","text":"<p>A continuaci\u00f3n configuraremos el nombre de la ventana:</p> <pre><code>root.title('Youtube Downloader')\n</code></pre> <p>El tama\u00f1o de la misma:</p> <pre><code>root.geometry('700x450')\n</code></pre> <p>Y el icono de la aplicaci\u00f3n:</p> <pre><code>root.iconbitmap('youtube.ico')\n</code></pre> <p>Para conseguir el icono de YouTube iremos a https://www.flaticon.es/icon-font-gratis/youtube_6422215?related_id=6422215 y descargaremos el icono en png. </p> <p>Despu\u00e9s convertiremos la imagen al formato <code>.ico</code> en https://convertio.co/es/png-ico/. </p> <p>Finalmente meteremos el icono en la misma carpeta en la que est\u00e1 nuestro <code>youtube_downloader.py</code>. Llamaremos a nuestro icono <code>youtube.ico</code></p> <p>Hasta el momento nuestro c\u00f3digo deber\u00eda verse as\u00ed:</p> <pre><code>from pytube import YouTube, Playlist\nimport customtkinter as ctk\nimport re\nimport threading\nimport os\n\n\nroot = ctk.CTk()\nroot.title('Youtube Downloader')\nroot.geometry('700x450')\nroot.iconbitmap('youtube.ico')\n\nroot.mainloop()\n</code></pre> <p>Ahora que tenemos listo nuestro <code>root</code> vamos a crear el resto de componentes de nuestra interfaz.</p>"},{"location":"codigo/logica/comprobando/","title":"Test final","text":"<p>Ya hemos terminado de escribir todo el c\u00f3digo del programa. \u00a1Comprueba que lo tienes todo bien!</p>"},{"location":"codigo/logica/comprobando/#codigo-completo","title":"C\u00f3digo completo","text":"<pre><code>from pytube import YouTube, Playlist\nimport customtkinter as ctk\nimport re\nimport threading\nimport os\n\n\n# Utilidades\ndef replace_invalid_chars(filename):\n    invalid_chars_regex = r'[&lt;&gt;:\"/\\\\|?*]'\n    return re.sub(invalid_chars_regex, ' ', filename)\n\n\ndef is_youtube_link(link):\n    pattern = r'^(https?://)?(www\\.)?(youtube\\.com|youtu\\.be)/(watch\\?v=|embed/|v/|playlist\\?list=)?([a-zA-Z0-9_-]{11})(\\&amp;.*list=([a-zA-Z0-9_-]+))?$'\n    match = re.match(pattern, link)\n    return match is not None\n\n\ndef sanitize_link(link):\n    sub = '&amp;ab_channel'\n    index = link.find(sub)\n    if index != -1:\n        return link[:index]\n    else:\n        return link\n\n\ndef open_file_dialog():\n    global file_path\n    file_path = ctk.filedialog.askdirectory()\n    if file_path:\n        output_label.configure(text=f'La descarga se guardar\u00e1 en: {file_path}')\n\n\ndef open_folder(folder):\n    os.startfile(folder)\n\n\n# Descargas\ndef dl_single(path, link):\n\n    if mp3_checked.get() == 'on':\n        video = YouTube(link)\n        stream = video.streams.get_audio_only()\n        complete_label.configure(\n            text=f'Descargando: \"{stream.title}\"...', text_color='cyan')\n        try:\n            stream.download(output_path=path,\n                            filename=f'{replace_invalid_chars(stream.title)}.mp3', timeout=20)\n            complete_label.configure(\n                text=f'Descarga de \"{stream.title}\" completada.', text_color='#07fc03')\n        except Exception as e:\n            complete_label.configure(\n                text=f\"'{stream.title}' {e}.\", text_color='orange')\n\n    if mp4_checked.get() == 'on':\n        video = YouTube(link)\n        stream = video.streams.filter(\n            progressive=True).get_highest_resolution()\n        complete_label.configure(\n            text=f'Descargando: \"{stream.title}\"...', text_color='cyan')\n        try:\n            stream.download(output_path=path,\n                            filename=f'{replace_invalid_chars(stream.title)}.mp4', timeout=20)\n            complete_label.configure(\n                text=f'Descarga de \"{stream.title}\" completada.', text_color='#07fc03')\n        except Exception as e:\n            complete_label.configure(\n                text=f'\"{stream.title}\" {e}.', text_color='orange')\n\n\ndef dl_playlist(path, link):\n    playlist = Playlist(link)\n\n    if mp3_checked.get() == 'on':\n        for i, video in enumerate(playlist.videos):\n\n            playlist_label.configure(\n                text=f'Downloading: {playlist.title} playlist')\n            complete_label.configure(\n                text=video.title, text_color='cyan')\n            count_label.configure(text=f'( {i+1} / {len(playlist.videos)} )')\n            try:\n                stream = video.streams.get_audio_only()\n                stream.download(output_path=f'{path}/{playlist.title}',\n                                filename=f'{replace_invalid_chars(stream.title)}.mp3', timeout=20)\n            except Exception as e:\n                complete_label.configure(\n                    text=f'{playlist.title} {e}.', text_color='orange')\n                continue\n\n        complete_label.configure(\n            text=f'{playlist.title} playlist download complete.', text_color='#07fc03')\n        playlist_label.configure(text='')\n        count_label.configure(text='')\n\n    if mp4_checked.get() == 'on':\n        for i, video in enumerate(playlist.videos):\n\n            playlist_label.configure(\n                text=f'Downloading: {playlist.title} playlist')\n            complete_label.configure(\n                text=video.title, text_color='cyan')\n            count_label.configure(text=f'( {i+1} / {len(playlist.videos)} )')\n            stream = video.streams.filter(\n                progressive=True).get_highest_resolution()\n\n            try:\n                stream.download(output_path=f'{path}/{playlist.title}',\n                                filename=f'{replace_invalid_chars(stream.title)}.mp4', timeout=20)\n            except Exception as e:\n                complete_label.configure(\n                    text=f'{playlist.title} {e}.', text_color='orange')\n                continue\n\n        complete_label.configure(\n            text=f'{playlist.title} playlist download complete.', text_color='#07fc03')\n        playlist_label.configure(text='')\n        count_label.configure(text='')\n\n\ndef download(path, link):\n    open_folder_button.pack_forget()\n    link = sanitize_link(link)\n    if is_youtube_link(link):\n        if path:\n            link_label.configure(text='')\n            if 'list' in link:\n                dl_playlist(path, link)\n\n            else:\n                dl_single(path, link)\n            open_folder_button.pack()\n    else:\n        link_label.configure(\n            text='Por favor, introduce un link de YouTube v\u00e1lido.', text_color='red')\n\n\n# Interfaz\nroot = ctk.CTk()\nroot.title('Youtube Downloader')\nroot.geometry('700x450')\nroot.iconbitmap('youtube.ico')\n\n\nlink_entry = ctk.CTkEntry(root,\n                          placeholder_text='Introduce un link o una lista de reproducci\u00f3n de YouTube',\n                          width=600)\nlink_entry.pack(pady=30)\nlink_label = ctk.CTkLabel(root, text='', text_color='red')\nlink_label.pack()\n\noutput_button = ctk.CTkButton(\n    root, text='Seleccionar directorio', command=open_file_dialog)\noutput_button.pack()\n\noutput_label = ctk.CTkLabel(root, text='', text_color='cyan')\noutput_label.pack()\n\nmp3_checked = ctk.StringVar(value=\"off\")\nmp4_checked = ctk.StringVar(value=\"off\")\n\nmp3_checkbox = ctk.CTkCheckBox(\n    master=root, text='.mp3', variable=mp3_checked,  onvalue='on', offvalue='off')\nmp3_checkbox.pack(pady=10)\n\nmp4_checkbox = ctk.CTkCheckBox(\n    master=root, text='.mp4', variable=mp4_checked,  onvalue='on', offvalue='off')\nmp4_checkbox.pack(pady=10)\n\ndownload_button = ctk.CTkButton(root, text='Descargar', command=lambda: threading.Thread(\n    target=download, args=(file_path, link_entry.get())).start())\ndownload_button.pack(pady=10)\n\nplaylist_label = ctk.CTkLabel(root, text='', wraplength=400, text_color='cyan')\nplaylist_label.pack()\n\ncomplete_label = ctk.CTkLabel(root, text='', wraplength=400)\ncomplete_label.pack()\n\ncount_label = ctk.CTkLabel(root, text='', text_color='cyan')\ncount_label.pack()\n\nopen_folder_button = ctk.CTkButton(root, text='Abrir descargas', command=lambda: threading.Thread(\n    target=open_folder, args=(file_path,)).start())\n\n\nroot.mainloop()\n\n</code></pre> <p>Ahora puedes comprobar que todo funcione correctamente. Ejecuta <code>youtube_downloader.py</code> y prueba todas las funciones.</p>"},{"location":"codigo/logica/descarga/","title":"Funci\u00f3n de descarga","text":"<p>Ahora uniremos las dos funciones de descarga en una:</p> <pre><code>def download(path, link):\n    open_folder_button.pack_forget()\n    link = sanitize_link(link)\n    if is_youtube_link(link):\n        if path:\n            link_label.configure(text='')\n            if 'list' in link:\n                dl_playlist(path, link)\n\n            else:\n                dl_single(path, link)\n            open_folder_button.pack()\n    else:\n        link_label.configure(\n            text='Por favor, introduce un link de YouTube v\u00e1lido.', text_color='red')\n</code></pre> <p>Empezaremos por los par\u00e1metros que admite nuestra funci\u00f3n: <code>path</code> y <code>link</code>, como en las anteriores.</p> <p>Haremos que el bot\u00f3n de abrir el directorio de descarga desaparezca con <code>.pack_forget()</code>, por si estuviese ah\u00ed a causa de una descarga anterior.</p> <p>Guardaremos el link sanitizado con nuestra funci\u00f3n <code>sanitize_link()</code>.</p> <p>Despu\u00e9s comprobaremos si el link es un link de YouTube con la funci\u00f3n <code>is_youtube_link()</code>, sino configuraremos la etiqueta <code>link_label</code> con el texto indicando que se debe de introducir un link de YouTube v\u00e1lido. Utilizaremos un <code>text_color</code> red.</p> <p>Luego comprobaremos si hay un <code>path</code>. Si es as\u00ed, configuraremos <code>link_label</code> para que no muestre ning\u00fan texto.</p> <p>Ahora comprobaremos si la palabra \"list\" est\u00e1 en <code>link</code>. Si es as\u00ed llamaremos a nuestra funci\u00f3n <code>dl_playlist()</code> con <code>path</code> y <code>link</code> como par\u00e1metros. Sino llamaremos a la funci\u00f3n <code>dl_single()</code> con los mismos par\u00e1metros.</p> <p>Haremos aparecer el bot\u00f3n de abrir descargas con <code>.pack()</code></p> <p>Ya tendr\u00edamos todo listo para vincular las funciones con los botones.</p>"},{"location":"codigo/logica/descarga_lista/","title":"Descarga de lista de reproducci\u00f3n","text":"<p>Crearemos la funci\u00f3n encargada de descargar listas de reproducci\u00f3n:</p> <pre><code>def dl_playlist(path, link):\n    playlist = Playlist(link)\n\n    if mp3_checked.get() == 'on':\n        for i, video in enumerate(playlist.videos):\n\n            playlist_label.configure(\n                text=f'Downloading: {playlist.title} playlist')\n            complete_label.configure(\n                text=video.title, text_color='cyan')\n            count_label.configure(text=f'( {i+1} / {len(playlist.videos)} )')\n            try:\n                stream = video.streams.get_audio_only()\n                stream.download(output_path=f'{path}/{playlist.title}',\n                                filename=f'{replace_invalid_chars(stream.title)}.mp3', timeout=20)\n            except Exception as e:\n                complete_label.configure(\n                    text=f'{playlist.title} {e}.', text_color='orange')\n                continue\n\n        complete_label.configure(\n            text=f'{playlist.title} playlist download complete.', text_color='#07fc03')\n        playlist_label.configure(text='')\n        count_label.configure(text='')\n\n    if mp4_checked.get() == 'on':\n        for i, video in enumerate(playlist.videos):\n\n            playlist_label.configure(\n                text=f'Downloading: {playlist.title} playlist')\n            complete_label.configure(\n                text=video.title, text_color='cyan')\n            count_label.configure(text=f'( {i+1} / {len(playlist.videos)} )')\n            stream = video.streams.filter(\n                progressive=True).get_highest_resolution()\n\n            try:\n                stream.download(output_path=f'{path}/{playlist.title}',\n                                filename=f'{replace_invalid_chars(stream.title)}.mp4', timeout=20)\n            except Exception as e:\n                complete_label.configure(\n                    text=f'{playlist.title} {e}.', text_color='orange')\n                continue\n\n        complete_label.configure(\n            text=f'{playlist.title} playlist download complete.', text_color='#07fc03')\n        playlist_label.configure(text='')\n        count_label.configure(text='')\n</code></pre> <p>La funci\u00f3n aceptar\u00e1 los mismos par\u00e1metros que la funci\u00f3n de descarga \u00fanica: <code>path</code> y <code>link</code>.</p> <p>Crearemos una instancia de <code>playlist()</code> con el link como par\u00e1metro y la guardaremos en la variable <code>playlist</code>.</p>"},{"location":"codigo/logica/descarga_lista/#mp3","title":".mp3","text":"<p>Comprobaremos si el checkbox de mp3 est\u00e1 en \"on\" y, si es as\u00ed, crearemos un bucle <code>for</code> para descargar todos los links de la lista.</p> <p>Haremos <code>for i, video in enumerate(playlist.videos)</code> para poder mostrar por qu\u00e9 v\u00eddeo vamos.</p> <p>Dentro configuraremos <code>playlist_label</code> con el t\u00edtulo de la lista de reproducci\u00f3n que estamos descargando y <code>complete_label</code> con el t\u00edtulo del v\u00eddeo que se est\u00e1 descargando con un <code>text_color</code> cyan. Configuraremos tambi\u00e9n <code>count_label</code> para que muestre el v\u00eddeo por el que vamos <code>i+1</code> (porque <code>i</code> vale <code>0</code> en la primera iteraci\u00f3n) y cu\u00e1ntos v\u00eddeos tiene la lista en total <code>len(playlist.videos)</code>.</p> <p>Luego crearemos un bloque \"try-except\". configuraremos <code>output_path</code> de forma que sea <code>path/playlist.title</code> para que se guarde todo en ese directorio. Despu\u00e9s haremos lo mismo que hicimos con la descarga \u00fanica, solo que despu\u00e9s de configurar la etiqueta para mostrar el error, introduciremos un <code>continue</code> para que siga con la lista.</p> <p>Al final configuraremos <code>complete_label</code> para que muestre que la lista ha terminado de descargarse.</p> <p>Configuraremos <code>playlist_label</code> para que no muestre nada y haremos lo mismo con <code>count_label</code>.</p>"},{"location":"codigo/logica/descarga_lista/#mp4","title":".mp4","text":"<p>Haremos lo mismo que con la parte de \".mp3\", cambiando <code>.get_audio_only()</code> por <code>.filter(progressive=True).get_highest_resolution()</code>. El resto del c\u00f3digo es igual a \".mp3\".</p> <p>Ahora que tenemos tanto la funci\u00f3n de descarga \u00fanica como la de descarga de lista de reproducci\u00f3n, podemos crear una funci\u00f3n que englobe las dos para nuestro bot\u00f3n de descarga.</p>"},{"location":"codigo/logica/descarga_unica/","title":"Descarga \u00fanica","text":"<p>Ahora iremos con las funciones de descarga. Estas son m\u00e1s complejas, as\u00ed que presta atenci\u00f3n:</p> <pre><code>def dl_single(path, link):\n\n    if mp3_checked.get() == 'on':\n        video = YouTube(link)\n        stream = video.streams.get_audio_only()\n        complete_label.configure(\n            text=f'Descargando: \"{stream.title}\"...', text_color='cyan')\n        try:\n            stream.download(output_path=path,\n                            filename=f'{replace_invalid_chars(stream.title)}.mp3', timeout=20)\n            complete_label.configure(\n                text=f'Descarga de \"{stream.title}\" completada.', text_color='#07fc03')\n        except Exception as e:\n            complete_label.configure(\n                text=f\"'{stream.title}' {e}.\", text_color='orange')\n\n\n    if mp4_checked.get() == 'on':\n        video = YouTube(link)\n        stream = video.streams.filter(\n            progressive=True).get_highest_resolution()\n        complete_label.configure(\n            text=f'Descargando: \"{stream.title}\"...', text_color='cyan')\n        try:\n            stream.download(output_path=path,\n                            filename=f'{replace_invalid_chars(stream.title)}.mp4', timeout=20)\n            complete_label.configure(\n                text=f'Descarga de \"{stream.title}\" completada.', text_color='#07fc03')\n        except Exception as e:\n            complete_label.configure(\n                text=f'\"{stream.title}\" {e}.', text_color='orange')\n\n\n</code></pre> <p>La funci\u00f3n aceptar\u00e1 como par\u00e1metros un <code>path</code>, que ser\u00e1 el directorio de descarga y un <code>link</code>, que ser\u00e1 el link de YouTube que se descargar\u00e1.</p>"},{"location":"codigo/logica/descarga_unica/#mp3","title":".mp3","text":"<p>Primeramente comprobaremos si el checkbox de mp3 <code>mp3_checked</code> est\u00e1 'on' con el m\u00e9todo <code>.get()</code>.</p> <p>Crearemos una instancia de Youtube <code>YouTube(link)</code> con el <code>link</code> como par\u00e1metro y la guardaremos en la variable <code>video</code>.</p> <p>Despu\u00e9s accederemos a los <code>streams</code> del <code>video</code> y llamaremos al m\u00e9todo <code>get_audio_only()</code> para coger solo el audio.</p> <p>Ahora configuraremos nuestro <code>complete_label</code> con el texto que indica que el v\u00eddeo se est\u00e1 descargando. Podemos acceder al t\u00edtulo del v\u00eddeo con <code>stream.title</code>. Le pondremos un <code>text_color</code> cyan.</p> <p>Dentro de un bloque \"try-except\", dentro del <code>try</code> le diremos que intente hacer la descarga de <code>stream</code>, poni\u00e9ndole en el par\u00e1metro <code>output_path</code> la variable <code>path</code> y como <code>filename</code> una \"f-string\" con lo que retorne la funci\u00f3n <code>replace_invalid_chars()</code> con <code>stream.title</code> seguido de \".mp3\".</p> <p>Luego configuramos <code>complete_label</code> con el texto de descarga completada y con un <code>text_color</code> <code>#07fc03</code>, que es un verde vistoso. Este texto aparecer\u00e1 cuando la descarga se haya completado.</p> <p>Dentro del <code>except</code> configuraremos <code>complete_label</code> para que muestre el error con un <code>text_color</code> naranja. Esto se mostrar\u00e1 si ha habido alg\u00fan error en la descarga.</p>"},{"location":"codigo/logica/descarga_unica/#mp4","title":".mp4","text":"<p>Para la parte en la que se descarga el .mp4 haremos lo mismo. La \u00fanica diferencia reside en la variable <code>stream</code>.</p> <p>Accederemos a los <code>streams</code> de <code>video</code> y accederemos al m\u00e9todo <code>filter()</code> y meteremos como par\u00e1metro <code>progressive=True</code>. Esto har\u00e1 que coja los streams que son \"progressive\". Estos tienen las pistas de audio y v\u00eddeo unidas, lo que nos ahorra trabajo. Por contra solo podemos acceder a una calidad de 720p como m\u00e1ximo.</p> <p>Luego accederemos al m\u00e9todo <code>.get_highest_resolution()</code>, lo que har\u00e1 que coja la m\u00e1xima resoluci\u00f3n disponible (720p como hemos dicho antes).</p> <p>Guardaremos el <code>filename</code> de la misma forma, cambiando la extensi\u00f3n a \".mp4\".</p> <p>Con esto ya tendr\u00edamos la funci\u00f3n que descarga un \u00fanico v\u00eddeo o canci\u00f3n. Estamos listos para seguir con la funci\u00f3n que descarga listas de reproducci\u00f3n.</p>"},{"location":"codigo/logica/utilidades/","title":"Utilidades","text":"<p>Ahora crearemos las funciones que se encargar\u00e1n de sanitizar los links y abrir el directorio de descarga una vez esta haya finalizado.</p> <p>Escribiremos estas funciones arriba del c\u00f3digo de la interfaz.</p>"},{"location":"codigo/logica/utilidades/#comprobar-link","title":"Comprobar link","text":"<p>Crearemos una funci\u00f3n que comprobar\u00e1 si el link es de YouTube:</p> <pre><code>def is_youtube_link(link):\n    pattern = r'^(https?://)?(www\\.)?(youtube\\.com|youtu\\.be)/(watch\\?v=|embed/|v/|playlist\\?list=)?([a-zA-Z0-9_-]{11})(\\&amp;.*list=([a-zA-Z0-9_-]+))?$'\n    match = re.match(pattern, link)\n    return match is not None\n</code></pre> <p>Recibir\u00e1 como par\u00e1metro el link que hayamos introducido. Luego guardaremos en la variable <code>pattern</code> la expresi\u00f3n regular con la que deber\u00e1 coincidir el link. Si quieres saber m\u00e1s sobre expresiones regulares puedes ir aqu\u00ed.</p> <p>Guardaremos lo que nos devuelve la funci\u00f3n <code>.match()</code> de <code>re</code> en la variable <code>match</code>. Si <code>pattern</code> y <code>link</code> coinciden nos devolver\u00e1 <code>True</code>, sino devolver\u00e1 <code>False</code>.</p> <p>Por \u00faltimo retornaremos <code>match</code> si no es <code>None</code>.</p>"},{"location":"codigo/logica/utilidades/#sanitizar-link","title":"Sanitizar link","text":"<p>Algunos navegadores que tienen Adblock activado a\u00f1aden al final de los links de YouTube la cadena \"&amp;ab_channel=nombre_del_canal\" y esto no lo registra la expresi\u00f3n regular de nuestra funci\u00f3n de comprobaci\u00f3n de links.</p> <p>Para solucionar esto crearemos una funci\u00f3n que quite esa parte del link si la tiene:</p> <pre><code>def sanitize_link(link):\n    sub = '&amp;ab_channel'\n    index = link.find(sub)\n    if index != -1:\n        return link[:index]\n    else:\n        return link\n</code></pre> <p>La funci\u00f3n tomar\u00e1 como par\u00e1metro el link. Meteremos en la variable <code>sub</code> la parte que queremos quitar.</p> <p>Luego guardaremos en la variable <code>index</code> el \u00edndice en el que aparece <code>sub</code> en <code>link</code>.</p> <p>Si el valor de <code>index</code> es diferente a <code>-1</code> quiere decir que <code>sub</code> se encuentra en <code>link</code>. Entonces retornamos <code>link</code> quitando la parte que empieza por <code>sub</code>. Sino retornamos el <code>link</code>, puesto que no contiene <code>sub</code>.</p>"},{"location":"codigo/logica/utilidades/#sanitizar-nombre-de-archivo","title":"Sanitizar nombre de archivo","text":"<p>Dado que Windows no admite los car\u00e1cteres <code>&lt;  &gt; : \u201c | ? * /</code> en los nombres de archivo, crearemos una funci\u00f3n que los sustituya por un espacio en blanco:</p> <pre><code>def replace_invalid_chars(filename):\n    invalid_chars_regex = r'[&lt;&gt;:\"/\\\\|?*]'\n    return re.sub(invalid_chars_regex, ' ', filename)\n</code></pre> <p>La funci\u00f3n toma como par\u00e1metro el nombre del archivo. Guardamos en la variable <code>invalid_chars_regex</code> la expresi\u00f3n regular que contiene los car\u00e1cteres prohibidos.</p> <p>Luego retornamos lo que nos devuelve el m\u00e9todo <code>.sub()</code> de <code>re</code>, sustituyendo los car\u00e1cteres prohibidos por un espacio en blanco.</p>"},{"location":"codigo/logica/utilidades/#seleccionar-directorio-de-descarga","title":"Seleccionar directorio de descarga","text":"<p>Para seleccionar el directorio donde se guardar\u00e1 la descarga escribiremos la siguiente funci\u00f3n:</p> <pre><code>def open_file_dialog():\n    global file_path\n    file_path = ctk.filedialog.askdirectory()\n    if file_path:\n        output_label.configure(text=f'La descarga se guardar\u00e1 en: {file_path}')\n</code></pre> <p>Definiremos la variable global <code>file_path</code> y le asignaremos el m\u00e9todo <code>ctk.filedialog.askdirectory()</code>. Esto abrir\u00e1 un di\u00e1logo con el que podremos seleccionar un directorio. Luego, si la variable <code>file_path</code> tiene valor, configuraremos nuestro <code>output_label</code> con el texto que indica d\u00f3nde se guardar\u00e1 la descarga.</p>"},{"location":"codigo/logica/utilidades/#abrir-directorio-de-descarga","title":"Abrir directorio de descarga","text":"<p>Por \u00faltimo crearemos la funci\u00f3n encargada de abrir el directorio de descarga:</p> <pre><code>def open_folder(folder):\n    os.startfile(folder)\n</code></pre> <p>Tomar\u00e1 como par\u00e1metro el directorio y abrir\u00e1 el mismo con <code>os.startfile()</code>.</p> <p>Nuestro c\u00f3digo deber\u00eda verse as\u00ed:</p> <pre><code>from pytube import YouTube, Playlist\nimport customtkinter as ctk\nimport re\nimport threading\nimport os\n\ndef replace_invalid_chars(filename):\n    invalid_chars_regex = r'[&lt;&gt;:\"/\\\\|?*]'\n    return re.sub(invalid_chars_regex, ' ', filename)\n\n\ndef is_youtube_link(link):\n    pattern = r'^(https?://)?(www\\.)?(youtube\\.com|youtu\\.be)/(watch\\?v=|embed/|v/|playlist\\?list=)?([a-zA-Z0-9_-]{11})(\\&amp;.*list=([a-zA-Z0-9_-]+))?$'\n    match = re.match(pattern, link)\n    return match is not None\n\n\ndef sanitize_link(link):\n    sub = '&amp;ab_channel'\n    index = link.find(sub)\n    if index != -1:\n        return link[:index]\n    else:\n        return link\n\n\ndef open_folder(folder):\n    os.startfile(folder)\n\ndef open_file_dialog():\n    global file_path\n    file_path = ctk.filedialog.askdirectory()\n    if file_path:\n        output_label.configure(text=f'La descarga se guardar\u00e1 en: {file_path}')\n\n# Interfaz\nroot = ctk.CTk()\nroot.title('Youtube Downloader')\nroot.geometry('700x450')\nroot.iconbitmap('youtube.ico')\n\n\nlink_entry = ctk.CTkEntry(root,\n                          placeholder_text='Introduce un link o una lista de reproducci\u00f3n de YouTube',\n                          width=600)\nlink_entry.pack(pady=30)\n\noutput_button = ctk.CTkButton(root, text='Seleccionar directorio')\noutput_button.pack()\n\noutput_label = ctk.CTkLabel(root, text='')\n\n\nmp3_checked = ctk.StringVar(value=\"off\")\nmp4_checked = ctk.StringVar(value=\"off\")\n\nmp3_checkbox = ctk.CTkCheckBox(\n    master=root, text='.mp3', variable=mp3_checked,  onvalue='on', offvalue='off')\nmp3_checkbox.pack(pady=10)\n\nmp4_checkbox = ctk.CTkCheckBox(\n    master=root, text='.mp4', variable=mp4_checked,  onvalue='on', offvalue='off')\nmp4_checkbox.pack(pady=10)\n\ndownload_button = ctk.CTkButton(root, text='Descargar')\ndownload_button.pack(pady=10)\n\nplaylist_label = ctk.CTkLabel(root, text='', wraplength=400, text_color='cyan')\nplaylist_label.pack()\n\ncomplete_label = ctk.CTkLabel(root, text='', wraplength=400)\ncomplete_label.pack()\n\nroot.mainloop()\n\n</code></pre> <p>Una vez tengamos esto podremos empezar con las funciones de descarga.</p>"},{"location":"codigo/logica/vinculacion/","title":"Vinculando las funciones a los botones","text":"<p>Aqu\u00ed es donde entra en acci\u00f3n el m\u00f3dulo <code>threading</code>. Como ya hemos visto en la explicaci\u00f3n sobre los m\u00f3dulos, <code>threading</code> nos permitir\u00e1 tener abiertos varios procesos a la vez, lo cual har\u00e1 que nuestro programa no se congele cuando ejecutemos acciones.</p>"},{"location":"codigo/logica/vinculacion/#seleccionar-directorio-de-descarga","title":"Seleccionar directorio de descarga","text":"<p>Ahora vincularemos la funci\u00f3n <code>open_file_dialog()</code> con el bot\u00f3n <code>output_button</code>:</p> <pre><code>output_button = ctk.CTkButton(root, text='Seleccionar directorio', command=open_file_dialog)\n</code></pre> <p>Como ves esto se hace colocando el par\u00e1metro <code>command</code> y asign\u00e1ndole la funci\u00f3n deseada.</p> <p>Puedes ejecutar el archivo y comprobar que funciona.</p>"},{"location":"codigo/logica/vinculacion/#boton-de-descarga","title":"Bot\u00f3n de descarga","text":"<p>A continuaci\u00f3n vincularemos la funci\u00f3n <code>download</code> con el bot\u00f3n <code>download_button</code>:</p> <pre><code>download_button = ctk.CTkButton(root, text='Descargar', command=lambda: threading.Thread(target=download, args=(file_path, link_entry.get())).start())\n</code></pre> <p>En <code>command</code> meteremos una funci\u00f3n <code>lambda</code>. En Tkinter, cuando metemos una funci\u00f3n en <code>command</code> a la cual le metemos argumentos, Tkinter interpreta que debe ejecutar dicha funci\u00f3n nada m\u00e1s abrir el programa. <code>lambda</code> nos evita eso.</p> <p>Si quieres saber m\u00e1s sobre <code>lambda</code> puedes ir aqu\u00ed.</p> <p>Dentro de <code>lambda</code> crearemos un nuevo <code>thread</code> con <code>threading.Thread()</code>.</p> <p><code>.Thread()</code> admite el par\u00e1metro <code>target</code>, que es la funci\u00f3n a la que apuntar\u00e1 el <code>thread</code>, y <code>args</code>, que son los argumentos de la funci\u00f3n <code>target</code>. En <code>args</code> pondremos <code>file_path</code>, que es el directorio donde se guardar\u00e1n las descargas y <code>link_entry.get()</code> para coger el link introducido por el usuario. As\u00ed tendr\u00edamos los dos par\u00e1metros que requiere la funci\u00f3n <code>download()</code>.</p> <p>Al final, despu\u00e9s del cierre de par\u00e9ntesis de <code>.Thread()</code>, a\u00f1adiremos <code>.start()</code> para indicar que se inicialice el <code>thread</code>.</p>"},{"location":"codigo/logica/vinculacion/#boton-para-abrir-directorio","title":"Bot\u00f3n para abrir directorio","text":"<p>Finalmente, haremos lo mismo con el bot\u00f3n <code>open_folder_button</code> y la funci\u00f3n <code>open_folder</code>:</p> <pre><code>open_folder_button = ctk.CTkButton(root, text='Abrir descargas', command=lambda: threading.Thread(\n    target=open_folder, args=(file_path,)).start())\n</code></pre> <p>Hay que tener en cuenta que lo que se le pasa como <code>args</code> a <code>.Thread()</code> es una tupla, por lo que si pasamos un solo argumento, hay que ponerle una coma detr\u00e1s para que lo tome como tal.</p> <p>Una vez vinculados los botones con sus respectivas funciones, comprobaremos que todo funciona correctamente.</p>"},{"location":"instalador/pyinstaller/","title":"Creando ejecutable con Pyinstaller","text":"<p>Vayamos ahora con la creaci\u00f3n del ejecutable.</p> <p>Abriremos una terminal e introduciremos el siguiente comando:</p> <p><code>pyinstaller --windowed --icon='youtube.ico' youtube_downloader.py</code></p> <p>Esto lanzar\u00e1 el proceso de crear el ejecutable.</p> <p>Una vez finalice el proceso, ver\u00e1s que se han creado dos carpetas en el directorio de tu proyecto:</p> <p></p> <p>Dentro de <code>dist/youtube_downloader</code> veremos la carpeta <code>_internal</code> y <code>youtube_downloader.exe</code>. En esta carpeta deberemos a\u00f1adir el icono de nuestra aplicaci\u00f3n <code>youtube.ico</code>.</p> <p>Una vez hecho esto podremos ejecutar <code>youtube_downloader.exe</code> y comprobar que funciona correctamente.</p> <p>Podremos crear un acceso directo del ejecutable y ponerlo donde queramos.</p> <p>Con esto finaliza el tutorial. \u00a1Espero que hayas disfrutado y aprendido mucho en el camino!</p>"},{"location":"primeros_pasos/empezando/","title":"Empezando nuestro proyecto","text":""},{"location":"primeros_pasos/empezando/#creacion-de-entorno-virtual-con-venv","title":"Creaci\u00f3n de entorno virtual con venv","text":"<p>Empezaremos creando un entorno virtual. Esto nos ayudar\u00e1 a la hora de crear el ejecutable, puesto que nuestro programa ser\u00e1 mucho m\u00e1s liviano al incluir solo las librer\u00edas que hemos instalado.</p> <p>En este tutorial trabajaremos con Visual Studio Code.</p> <p>Crearemos nuestro entorno virtual con venv.</p> <p>Crearemos una carpeta donde deseemos y la abriremos con VSC. Abriremos una nueva terminal <code>Ctrl</code> + <code>\u00d1</code> e introduciremos el siguiente comando:</p> <p><code>python -m venv env</code></p> <p>Puedes ponerle el nombre que quieras. Nosotros lo llamaremos \"env\".</p> <p>As\u00ed habremos creado nuestro entorno virtual. A continuaci\u00f3n tendremos que activarlo con el comando:</p> <p><code>source env/Scripts/activate</code></p> <p>Recuerda que tendr\u00e1s que activarlo siempre que abras de nuevo el proyecto.</p> <p>Ahora estamos listos para instalar las librer\u00edas que necesitaremos.</p>"},{"location":"primeros_pasos/imports/","title":"Importando librer\u00edas","text":""},{"location":"primeros_pasos/imports/#creando-youtube_downloaderpy","title":"Creando youtube_downloader.py","text":"<p>Ahora que tenemos todo listo, crearemos un nuevo archivo con nombre <code>youtube_downloader.py</code>.</p> <p>Editaremos el archivo y al principio de este empezaremos a importar las librer\u00edas que necesitaremos.</p>"},{"location":"primeros_pasos/imports/#pytube","title":"Pytube","text":"<p>Empezaremos importando  <code>pytube</code> para descargar tanto links simples como listas de reproducci\u00f3n. Para ello escribiremos:</p> <p><code>from pytube import YouTube, Playlist</code></p>"},{"location":"primeros_pasos/imports/#customtkinter","title":"Customtkinter","text":"<p>Ahora importaremos <code>customtkinter</code> para crear la interfaz gr\u00e1fica de nuestro programa:</p> <p><code>import customtkinter as ctk</code></p> <p>\"as ctk\" quiere decir que importaremos la librer\u00eda con el alias \"ctk\", as\u00ed no tendremos que escribir \"customtkinter\" cada vez que queramos llamar las funciones del m\u00f3dulo.</p>"},{"location":"primeros_pasos/imports/#re","title":"Re","text":"<p>Tambi\u00e9n importaremos el m\u00f3dulo <code>re</code> (Regular expressions) para sanear los links y nombres de archivos, ya que los t\u00edtulos de los v\u00eddeos o canciones que descargaremos contienen car\u00e1cteres no permitidos en Windows para nombres de archivos.</p> <p><code>import re</code></p>"},{"location":"primeros_pasos/imports/#threading","title":"Threading","text":"<p>Este m\u00f3dulo es muy importante. Nos permitir\u00e1 realizar varios procesos a la vez y, por lo tanto, poder hacer otras tareas en nuestro programa mientras se ejecuta el proceso de descarga. Escribimos:</p> <p><code>import threading</code></p>"},{"location":"primeros_pasos/imports/#os","title":"Os","text":"<p>Por \u00faltimo, importaremos el m\u00f3dulo <code>os</code> para abrir la carpeta en la que hayamos descargado los v\u00eddeos o canciones. Importamos as\u00ed:</p> <p><code>import os</code></p> <p>Ya tenemos todo listo para escribir el c\u00f3digo de nuestro programa.</p>"},{"location":"primeros_pasos/librerias/","title":"Librer\u00edas que necesitaremos","text":""},{"location":"primeros_pasos/librerias/#pytube","title":"Pytube","text":"<p>Para descargar la m\u00fasica y los v\u00eddeos de YouTube haremos uso de la librer\u00eda pytube.</p> <p>Abriremos una terminal e introduciremos el siguiente comando:</p> <p><code>pip install pytube</code></p>"},{"location":"primeros_pasos/librerias/#customtkinter","title":"Customtkinter","text":"<p>Para crear la interfaz gr\u00e1fica (GUI) utilizaremos customtkinter.</p> <p>Para instalarla haremos lo mismo con el siguiente comando:</p> <p><code>pip install customtkinter</code></p>"},{"location":"primeros_pasos/librerias/#pyinstaller","title":"Pyinstaller","text":"<p>Crearemos un ejecutable (.exe) de nuestro programa con pyinstaller.</p> <p>Instalaremos con el siguiente comando:</p> <p><code>pip install pyinstaller</code></p> <p>Una vez tengamos instaladas las librer\u00edas estaremos listos para empezar a crear nuestro c\u00f3digo.</p>"}]}